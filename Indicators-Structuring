# ================================================================
# Pillar - Financial Readiness
# Global Financial Readiness Index (GFRI) — 2024 Final Pipeline 
# Derived from: World Bank Global Findex Database
#
# What this script does (with 2024 enforced):
#   A) Read Findex Excel → keep national totals for 2024 ONLY (error if missing)
#   B) Select finalized indicators (Access & Usage)
#   C) Clean and normalize indicators (0–100% → 0–1)
#   D) Build sub-indices: Access_n, Usage_n
#   E) Build final composite: GFRI (equal-weight Access & Usage)
#   F) Export three layers: indicators-only, pre-index (with GFRI), final lean file
# ================================================================

suppressPackageStartupMessages({
  library(readxl)
  library(readr)
  library(dplyr)
  library(stringr)
})

# -----------------------------
# PATHS (EDIT IF NEEDED)
# -----------------------------
xlsx_path     <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/GlobalFindexDatabase2025 (1).xlsx"
export_dir    <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/export"
preindex_dir  <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/cleaned-Data/pre-index"
final_dir     <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/cleaned-Data/FINAL"

dir.create(export_dir,   recursive = TRUE, showWarnings = FALSE)
dir.create(preindex_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(final_dir,    recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# SETTINGS — force 2024 and stop if unavailable
# -----------------------------
target_year <- 2024

# -----------------------------
# HELPERS
# -----------------------------

## Convert strings like "34,5%" / " 27 " to numeric
to_num <- function(x) {
  if (is.numeric(x)) return(x)
  x <- gsub(",", "", as.character(x), fixed = TRUE)
  x <- gsub("%", "", x, fixed = TRUE)
  x <- trimws(x)
  suppressWarnings(as.numeric(x))
}

## Clip percentages to [0,100]
clip_pct <- function(v) {
  x <- to_num(v)
  x[x < 0]   <- 0
  x[x > 100] <- 100
  x
}

## Min–Max normalize to [0,1] across countries
normalize_minmax <- function(v) {
  x <- to_num(v)
  if (all(is.na(x))) return(rep(NA_real_, length(x)))
  lo <- suppressWarnings(min(x, na.rm = TRUE))
  hi <- suppressWarnings(max(x, na.rm = TRUE))
  if (!is.finite(lo) || !is.finite(hi) || lo == hi) return(rep(0.5, length(x)))
  (x - lo) / (hi - lo)
}

## Pick first existing column among aliases (e.g., digital payments naming)
pick_first_existing <- function(df, candidates, new_name) {
  have <- candidates[candidates %in% names(df)]
  df[[new_name]] <- if (length(have) == 0) NA_real_ else to_num(df[[have[1]]])
  df
}

# ================================================================
# A) READ EXCEL → KEEP NATIONAL TOTALS FOR 2024 (FAIL IF MISSING)
# ================================================================
message("Reading Global Findex Excel…")
raw <- read_excel(xlsx_path, sheet = "Data")

# Drop any non-data rows by requiring numeric year; standardize groups
data <- raw %>%
  mutate(.yr = suppressWarnings(as.numeric(year))) %>%
  filter(!is.na(.yr)) %>%
  select(-.yr) %>%
  mutate(
    group  = ifelse(is.na(group),  "all", tolower(trimws(group))),
    group2 = ifelse(is.na(group2), "all", tolower(trimws(group2)))
  )

# Validate that 2024 exists
avail_years <- sort(unique(suppressWarnings(as.numeric(data$year))))
message("Available survey years: ", paste(avail_years, collapse = ", "))
if (!any(avail_years == target_year)) {
  stop(paste0("❌ Requested year ", target_year, " not found in file. ",
              "Please verify your source or update the file with 2024 data."))
}

# Filter to national totals for 2024
df <- data %>%
  filter(year == target_year, group == "all", group2 == "all")

stopifnot("❌ No national-total rows for 2024. Check 'group'/'group2' values." = nrow(df) > 0)

# ================================================================
# B) SELECT FINALIZED INDICATORS (Access & Usage)
#    Access: account_any, account_mobile
#    Usage : borrow_any, save_formal, digital_payments (alias-robust)
# ================================================================
df <- df %>%
  select(
    countrynewwb, codewb, year, regionwb24_hi, incomegroupwb24, pop_adult,
    account.t.d, mobileaccount.t.d, borrow.any.t.d, fin4.d,
    everything()
  ) %>%
  rename(
    country        = countrynewwb,
    code           = codewb,
    region         = regionwb24_hi,
    incomegroup    = incomegroupwb24,
    account_any    = account.t.d,         # % adults with any account
    account_mobile = mobileaccount.t.d,   # % adults with mobile money account
    borrow_any     = borrow.any.t.d,      # % adults borrowed any money
    save_formal    = fin4.d               # % adults saved at a financial institution
  )

# Try common aliases for digital payments
digital_candidates <- c("digital_payments", "pay.digital.t.d", "fin11_2a", "fin11_2b", "pay.digital.any.t.d")
df <- pick_first_existing(df, digital_candidates, "digital_payments")

# ================================================================
# C) CLEAN & NORMALIZE INDICATORS (0–100% → 0–1)
# ================================================================
indicators <- df %>%
  mutate(
    country          = str_trim(as.character(country)),
    code             = str_trim(as.character(code)),
    region           = str_trim(as.character(region)),
    incomegroup      = str_trim(as.character(incomegroup)),
    pop_adult        = to_num(pop_adult),

    # RAW % values (validated to [0,100])
    account_any      = clip_pct(account_any),
    account_mobile   = clip_pct(account_mobile),
    borrow_any       = clip_pct(borrow_any),
    save_formal      = clip_pct(save_formal),
    digital_payments = clip_pct(digital_payments),

    # Normalized 0–1 values (for index building)
    account_any_n      = normalize_minmax(account_any),
    account_mobile_n   = normalize_minmax(account_mobile),
    borrow_any_n       = normalize_minmax(borrow_any),
    save_formal_n      = normalize_minmax(save_formal),
    digital_payments_n = normalize_minmax(digital_payments)
  ) %>%
  arrange(country) %>%
  distinct(country, .keep_all = TRUE) %>%
  select(
    country, code, year, region, incomegroup, pop_adult,
    # indicators (RAW %)
    account_any, account_mobile, borrow_any, save_formal, digital_payments,
    # indicators (normalized 0–1)
    account_any_n, account_mobile_n, borrow_any_n, save_formal_n, digital_payments_n
  )

# Diagnostics for coverage
message("Countries in indicators (2024): ", nrow(indicators))
missing_raw <- sapply(indicators[, c("account_any","account_mobile","borrow_any","save_formal","digital_payments")],
                      function(x) sum(is.na(x)))
message("Missing (raw %) by indicator:"); print(missing_raw)

# Export indicators-only (2024)
ind_out <- file.path(export_dir, "Findex_FINALIZED_indicators_2024.csv")
write_csv(indicators, ind_out)
message("✅ Exported INDICATORS-ONLY: ", ind_out)

# ================================================================
# D) PRE-INDEX: BUILD SUB-INDICES (Access_n, Usage_n) + FINAL GFRI
# ================================================================
x <- read_csv(ind_out, show_col_types = FALSE)

# Validate normalized columns exist
need <- c("account_any_n","account_mobile_n","borrow_any_n","save_formal_n","digital_payments_n")
miss <- setdiff(need, names(x))
if (length(miss) > 0) stop("❌ Missing normalized columns: ", paste(miss, collapse = ", "))

key_cols <- intersect(c("country","code","year","region","incomegroup","pop_adult"), names(x))

preindex <- x %>%
  mutate(
    # Access sub-index: equal weight, robust to 1 indicator present
    access_k = (!is.na(account_any_n)) + (!is.na(account_mobile_n)),
    Access_n = dplyr::case_when(
      access_k == 2 ~ rowMeans(cbind(account_any_n, account_mobile_n), na.rm = TRUE),
      access_k == 1 ~ ifelse(!is.na(account_any_n), account_any_n, account_mobile_n),
      TRUE          ~ NA_real_
    ),

    # Usage sub-index: equal weight across up to 3 components
    usage_k = (!is.na(borrow_any_n)) + (!is.na(save_formal_n)) + (!is.na(digital_payments_n)),
    Usage_n = dplyr::case_when(
      usage_k >= 1 ~ rowMeans(cbind(borrow_any_n, save_formal_n, digital_payments_n), na.rm = TRUE),
      TRUE         ~ NA_real_
    ),

    # Final composite (GFRI): equal-weight mean of Access_n & Usage_n
    GFRI = dplyr::case_when(
      !is.na(Access_n) & !is.na(Usage_n) ~ (Access_n + Usage_n) / 2,
      !is.na(Access_n) &  is.na(Usage_n) ~ Access_n,
       is.na(Access_n) & !is.na(Usage_n) ~ Usage_n,
      TRUE                               ~ NA_real_
    )
  ) %>%
  select(all_of(key_cols),
         # final composite + sub-indices
         GFRI, Access_n, Usage_n,
         # components (normalized) for audit
         account_any_n, account_mobile_n, borrow_any_n, save_formal_n, digital_payments_n,
         # components (raw %) for audit
         account_any,   account_mobile,   borrow_any,   save_formal,   digital_payments) %>%
  arrange(country)

message("Rows (countries) in PRE-INDEX (2024): ", nrow(preindex))
message("Coverage (non-missing): Access_n=", sum(!is.na(preindex$Access_n)),
        " | Usage_n=", sum(!is.na(preindex$Usage_n)),
        " | GFRI=",     sum(!is.na(preindex$GFRI)))

# Export pre-index (with final composite)
pre_out <- file.path(preindex_dir, "GlobalFindex_FinAccessUsage_preindex_2024_GFRI.csv")
write_csv(preindex, pre_out)
message("✅ Exported PRE-INDEX + GFRI: ", pre_out)

# ================================================================
# E) FINAL LEAN EXPORT — PILLAR-READY (GFRI + SUB-INDICES)
# ================================================================
final <- preindex %>%
  select(country, code, year, region, incomegroup,
         GFRI, Access_n, Usage_n)

final_out <- file.path(final_dir, "GlobalFinancialReadinessIndex_GFRI_2024.csv")
write_csv(final, final_out)
message("✅ Exported FINAL composite (pillar-ready): ", final_out)

# ================================================================
# SUMMARY
# ================================================================
message("\nSummary (2024):")
message("• Indicators-only (selected & normalized): ", ind_out)
message("• Pre-index (components + Access/Usage + GFRI): ", pre_out)
message("• FINAL (lean, pillar-ready): ", final_out)












#2###################################


# ================================================================
# Pillar - Trade & Investment 
# Tariff Restrictiveness Index (TRI) — Final Pre-Index Pipeline
# Mirrors GFRI pipeline structure (no extra harmonization)
# Source: WTO IDB/CTS indicator extracts
#
# Steps:
#   A) Read 6 WTO Excel files
#   B) Tidy (detect 'Reporting Economy'), reshape long
#   C) Restrict to 2019–2024 and average per country
#   D) Normalize to [0,1] (invert duties; keep duty-free as-is)
#   E) Build sub-indices: TariffLevel_n, DutyFree_n
#   F) TRI = 0.5*TariffLevel_n + 0.5*DutyFree_n
#   G) Export: indicators-only, pre-index, final lean
# ================================================================

suppressPackageStartupMessages({
  library(readxl)
  library(readr)
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(purrr)
})

# -----------------------------
# PATHS (same as GFRI)
# -----------------------------
tariff_dir   <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/Tariff"
export_dir   <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/export"
preindex_dir <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/cleaned-Data/pre-index"
final_dir    <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/cleaned-Data/FINAL"

dir.create(export_dir,   recursive = TRUE, showWarnings = FALSE)
dir.create(preindex_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(final_dir,    recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# SETTINGS
# -----------------------------
period_min <- 2019
period_max <- 2024
valid_year_min <- 2011  # WTO files typically 2011–2024
valid_year_max <- 2024

# Indicator → file map (your files)
tariff_files <- list(
  Simple   = file.path(tariff_dir, "WtoData_20250905143957.xlsx"), # MFN simple avg (%)
  Weighted = file.path(tariff_dir, "WtoData_20250905144029.xlsx"), # MFN trade-weighted avg (%)
  DutyFree = file.path(tariff_dir, "WtoData_20250905144049.xlsx"), # MFN duty-free share (%)
  Ag       = file.path(tariff_dir, "WtoData_20250905144140.xlsx"), # MFN Ag simple avg (%)
  NonAg    = file.path(tariff_dir, "WtoData_20250905144207.xlsx"), # MFN Non-Ag simple avg (%)
  Max      = file.path(tariff_dir, "WtoData_20250905144310.xlsx")  # MFN maximum duty (%)
)
# (WtoData_20250905143821.xlsx kept out unless needed.)

# -----------------------------
# HELPERS (GFRI-style)
# -----------------------------
to_num <- function(x) {
  if (is.numeric(x)) return(x)
  x <- as.character(x)
  x <- gsub(",", "", x, fixed = TRUE)
  x <- gsub("%", "", x, fixed = TRUE)
  x <- trimws(x)
  x[x %in% c("", "..", "...", "—", "–")] <- NA
  suppressWarnings(as.numeric(x))
}

normalize_minmax <- function(v) {
  x <- to_num(v)
  if (all(is.na(x))) return(rep(NA_real_, length(x)))
  lo <- suppressWarnings(min(x, na.rm = TRUE))
  hi <- suppressWarnings(max(x, na.rm = TRUE))
  if (!is.finite(lo) || !is.finite(hi) || lo == hi) return(rep(0.5, length(x)))
  (x - lo) / (hi - lo)
}

find_header_row <- function(df) {
  first_col <- tolower(trimws(as.character(df[[1]])))
  hit <- which(first_col %in% c("reporting economy", "reporting economy:"))
  if (length(hit) == 0) hit <- which(grepl("reporting\\s*economy", first_col, perl = TRUE))
  if (length(hit) == 0) stop("❌ Could not find 'Reporting Economy' header row.")
  hit[1]
}

# ---- Hardened tidy: guards against NA/blank headers & duplicated names
tidy_tariff <- function(path, indicator_label, sheet = 1) {
  df  <- read_excel(path, sheet = sheet, col_names = FALSE)
  hdr <- find_header_row(df)
  
  # Raw header cells after col 1
  hdr_cells <- as.character(unlist(df[hdr, -1]))
  # Parse candidate years, keep only valid 4-digit within range
  years <- suppressWarnings(as.integer(gsub("[^0-9]", "", hdr_cells)))
  valid <- which(!is.na(years) & years >= valid_year_min & years <= valid_year_max)
  
  if (length(valid) == 0) stop("❌ No valid year columns detected in: ", basename(path))
  
  # Build a clean rectangular slice: country + selected year columns
  # shift by 1 because we dropped the first column in hdr_cells
  cols_keep <- c(1, valid + 1)
  df2 <- df[(hdr + 1):nrow(df), cols_keep, drop = FALSE]
  
  # Assign safe names: "country", then numeric years as strings
  nm <- c("country", as.character(years[valid]))
  # Make absolutely unique to satisfy tidyr
  nm <- make.unique(nm, sep = "_")
  names(df2) <- nm
  
  # Some WTO sheets may have "Notes" or "Source" trailing rows; drop those where all year cols are NA
  yr_cols <- nm[-1]
  all_na_row <- apply(df2[, yr_cols, drop = FALSE], 1, function(r) all(is.na(to_num(r))))
  df2 <- df2[!all_na_row, , drop = FALSE]
  
  # Long
  df2 %>%
    pivot_longer(all_of(yr_cols), names_to = "year", values_to = "value") %>%
    mutate(
      country  = str_trim(as.character(df2$country[rep(seq_len(nrow(df2)), each = length(yr_cols))])),
      year     = suppressWarnings(as.integer(year)),
      value    = to_num(value),
      indicator = indicator_label
    ) %>%
    filter(!is.na(country), country != "", !is.na(year))
}

# ================================================================
# A–C) READ → TIDY → AVERAGE 2019–2024
# ================================================================
message("Reading WTO tariff indicators and averaging ", period_min, "–", period_max, "…")

tariff_long <- map2_df(names(tariff_files), tariff_files, \(ind, fp) {
  if (!file.exists(fp)) stop("❌ Missing file: ", fp)
  out <- tidy_tariff(fp, ind)
  if (nrow(out) == 0) stop("❌ No rows after tidy for file: ", basename(fp))
  out
})

tariff_avg <- tariff_long %>%
  filter(year >= period_min, year <= period_max) %>%
  group_by(country, indicator) %>%
  summarise(avg_value = mean(value, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = indicator, values_from = avg_value)

# ================================================================
# D) NORMALIZE (duties inverted; duty-free not inverted)
# ================================================================
tariff_norm <- tariff_avg %>%
  mutate(
    Simple_n   = 1 - normalize_minmax(Simple),     # lower duty = better
    Weighted_n = 1 - normalize_minmax(Weighted),
    Ag_n       = 1 - normalize_minmax(Ag),
    NonAg_n    = 1 - normalize_minmax(NonAg),
    Max_n      = 1 - normalize_minmax(Max),
    DutyFree_n =      normalize_minmax(DutyFree)   # higher duty-free = better
  )

# ================================================================
# E) PRE-INDEX SUB-INDICES + TRI (GFRI-style)
# ================================================================
preindex <- tariff_norm %>%
  mutate(
    level_k = rowSums(!is.na(across(c(Simple_n, Weighted_n, Ag_n, NonAg_n, Max_n)))),
    TariffLevel_n = dplyr::case_when(
      level_k >= 1 ~ rowMeans(across(c(Simple_n, Weighted_n, Ag_n, NonAg_n, Max_n)), na.rm = TRUE),
      TRUE         ~ NA_real_
    ),
    TRI = dplyr::case_when(
      !is.na(TariffLevel_n) & !is.na(DutyFree_n) ~ (TariffLevel_n + DutyFree_n) / 2,
      !is.na(TariffLevel_n) &  is.na(DutyFree_n) ~ TariffLevel_n,
      is.na(TariffLevel_n) & !is.na(DutyFree_n) ~ DutyFree_n,
      TRUE                                       ~ NA_real_
    )
  ) %>%
  arrange(country)

# ================================================================
# F) EXPORTS — indicators-only, pre-index, final
# ================================================================
indicators_only <- preindex %>%
  select(
    country,
    # raw averaged values
    Simple, Weighted, DutyFree, Ag, NonAg, Max,
    # normalized
    Simple_n, Weighted_n, DutyFree_n, Ag_n, NonAg_n, Max_n
  )

ind_out <- file.path(export_dir, "WTO_Tariff_indicators_avg_2019_2024.csv")
write_csv(indicators_only, ind_out)
message("✅ Exported INDICATORS-ONLY: ", ind_out)

pre_out_df <- preindex %>%
  select(
    country,
    TariffLevel_n, DutyFree_n, TRI,
    Simple_n, Weighted_n, Ag_n, NonAg_n, Max_n
  )

pre_out <- file.path(preindex_dir, "WTO_Tariff_TRI_preindex_2019_2024.csv")
write_csv(pre_out_df, pre_out)
message("✅ Exported PRE-INDEX + TRI: ", pre_out)

final_df <- preindex %>%
  select(country, TRI)

final_out <- file.path(final_dir, "TariffRestrictivenessIndex_TRI_2019_2024.csv")
write_csv(final_df, final_out)
message("✅ Exported FINAL composite (pillar-ready): ", final_out)

# ================================================================
# SUMMARY
# ================================================================
message("\nSummary:")
message("• Indicators-only: ", ind_out)
message("• Pre-index (sub-indices + TRI): ", pre_out)
message("• FINAL lean: ", final_out)










#3#####################################################################
# ================================================================
# ERI Data Construction Pipeline (Replication Ready)
# Cleans and assembles inputs into `eri_long` for 2020–2024
# Handles missing or messy sheets gracefully
# ================================================================

# ---- Libraries ----
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(readr)

# ---- File path ----
file_path <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/EIelectron-Stats-Review-ALL-data.xlsx"
stopifnot(file.exists(file_path))

# ---- Helper: Clean + reshape a sheet ----
tidy_years <- function(sheet, var_name) {
  df <- read_excel(file_path, sheet = sheet, skip = 2)
  
  country_col <- names(df)[1]
  year_cols   <- names(df)[str_detect(names(df), "^(19|20)\\d{2}")]
  
  if (length(year_cols) == 0) {
    message("⚠️ Skipping sheet: ", sheet, " (no usable year columns)")
    return(NULL)
  }
  
  # normalize types to avoid pivot errors
  df[year_cols] <- lapply(df[year_cols], as.character)
  
  df %>%
    pivot_longer(cols = all_of(year_cols),
                 names_to = "Year_raw",
                 values_to = "Value") %>%
    mutate(
      Country  = as.character(.data[[country_col]]),
      Year     = as.integer(str_extract(Year_raw, "^(19|20)\\d{2}")),
      Variable = var_name,
      Value    = suppressWarnings(as.numeric(Value))
    ) %>%
    filter(!is.na(Year),
           !is.na(Country),
           Country != "",
           !str_starts(Country, "#"),
           !str_starts(Country, "\\*"),
           !str_detect(Country, "^Total")) %>%
    group_by(Country, Year, Variable) %>%
    summarise(Value = mean(Value, na.rm = TRUE), .groups = "drop")
}

# ---- Collect ERI input sheets ----
pieces <- list(
  tidy_years("Electricity Generation - TWh", "Electricity generation"),
  tidy_years("Hydro Generation - TWh",        "Hydro generation"),
  tidy_years("Solar Installed Capacity",      "Solar capacity"),
  tidy_years("Wind Installed Capacity",       "Wind capacity"),
  tidy_years("Grid Scale BESS Capacity",      "BESS capacity"),
  tidy_years("CCUS Capture Capacity",         "CCUS capacity"),
  tidy_years("Carbon Prices",                 "Carbon price")
)

# ---- Keep only valid (non-NULL) datasets ----
valid_pieces <- compact(pieces)

# ---- Assemble master ERI dataset ----
eri_long <- bind_rows(valid_pieces) %>%
  filter(Year >= 2020, Year <= 2024) %>%
  distinct(Country, Year, Variable, .keep_all = TRUE)

message("✅ eri_long built with ", nrow(eri_long), " rows, ",
        dplyr::n_distinct(eri_long$Country), " countries, ",
        dplyr::n_distinct(eri_long$Variable), " variables.")

# ---- Coverage summary for replication appendix ----
summary_info <- eri_long %>%
  group_by(Variable) %>%
  summarise(
    Countries = n_distinct(Country),
    Years     = paste0(min(Year, na.rm = TRUE), "-", max(Year, na.rm = TRUE)),
    Obs       = n(),
    .groups   = "drop"
  )

print(summary_info, n = Inf)

# ---- Save tidy input dataset ----
preindex_dir <- file.path(dirname(file_path), "cleaned-Data", "pre-index")
dir.create(preindex_dir, recursive = TRUE, showWarnings = FALSE)

readr::write_csv(
  eri_long,
  file.path(preindex_dir, "ERI_inputs_long_2020_2024.csv")
)

#########




# ================================================================
# ERI Pipeline: Data Construction → Scoring → Export
# Robust to missing indicators; reproducible replication script
# ================================================================

# ---- Libraries ----
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(readr)

# ---- File path ----
file_path <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/EIelectron-Stats-Review-ALL-data.xlsx"
stopifnot(file.exists(file_path))

# ================================================================
# (A) Data Construction
# ================================================================

# --- Helper: Clean + reshape any sheet ---
tidy_years <- function(sheet, var_name) {
  df <- read_excel(file_path, sheet = sheet, skip = 2)
  country_col <- names(df)[1]
  year_cols   <- names(df)[str_detect(names(df), "^(19|20)\\d{2}")]
  
  if (length(year_cols) == 0) {
    message("⚠️ Skipping sheet: ", sheet, " (no usable year columns)")
    return(NULL)
  }
  
  df[year_cols] <- lapply(df[year_cols], as.character)
  
  df %>%
    pivot_longer(cols = all_of(year_cols),
                 names_to = "Year_raw",
                 values_to = "Value") %>%
    mutate(
      Country  = as.character(.data[[country_col]]),
      Year     = as.integer(str_extract(Year_raw, "^(19|20)\\d{2}")),
      Variable = var_name,
      Value    = suppressWarnings(as.numeric(Value))
    ) %>%
    filter(!is.na(Year),
           !is.na(Country),
           Country != "",
           !str_starts(Country, "#"),
           !str_starts(Country, "\\*"),
           !str_detect(Country, "^Total")) %>%
    group_by(Country, Year, Variable) %>%
    summarise(Value = mean(Value, na.rm = TRUE), .groups = "drop")
}

# --- Collect relevant ERI inputs ---
pieces <- list(
  tidy_years("Electricity Generation - TWh", "Electricity generation"),
  tidy_years("Hydro Generation - TWh",        "Hydro generation"),
  tidy_years("Solar Installed Capacity",      "Solar capacity"),
  tidy_years("Wind Installed Capacity",       "Wind capacity"),
  tidy_years("Grid Scale BESS Capacity",      "BESS capacity"),
  tidy_years("CCUS Capture Capacity",         "CCUS capacity"),
  tidy_years("Carbon Prices",                 "Carbon price")
)

# --- Assemble tidy long panel ---
eri_long <- bind_rows(compact(pieces)) %>%
  filter(Year >= 2020, Year <= 2024) %>%
  distinct(Country, Year, Variable, .keep_all = TRUE)

message("✅ eri_long built with ", nrow(eri_long), " rows, ",
        n_distinct(eri_long$Country), " countries, ",
        n_distinct(eri_long$Variable), " variables.")

# ================================================================
# (B) ERI Scoring (safe for missing indicators)
# ================================================================

# ---- Settings ----
target_year   <- 2024L
cf_solar      <- 0.20
cf_wind       <- 0.35
winsor_probs  <- c(0.05, 0.95)

pillar_weights <- c(clean = 0.40, flex = 0.30, policy = 0.30)
w_clean  <- c(hydro_share = 0.40, vre_eq_share = 0.60)
w_flex   <- c(bess_per_twh = 1.00)
w_policy <- c(ccus_per_twh = 0.50, carbon_price = 0.50)

# ---- Helpers ----
winsorize_vec <- function(x, probs = c(0.05, 0.95)) {
  if (all(is.na(x))) return(x)
  qs <- stats::quantile(x, probs = probs, na.rm = TRUE, names = FALSE)
  pmin(pmax(x, qs[1]), qs[2])
}
normalize_minmax_01 <- function(v) {
  if (all(is.na(v))) return(rep(NA_real_, length(v)))
  lo <- min(v, na.rm = TRUE); hi <- max(v, na.rm = TRUE)
  if (!is.finite(lo) || !is.finite(hi) || lo == hi) return(rep(0.5, length(v)))
  (v - lo) / (hi - lo)
}
weighted_bucket_dynamic <- function(values_named, weights_named) {
  present <- names(values_named)[!is.na(values_named)]
  if (length(present) == 0) return(NA_real_)
  ww <- weights_named[present]
  ww <- ww / sum(ww)
  sum(values_named[present] * ww)
}

# ---- Build features for 2024 ----
features_2024 <- eri_long %>%
  filter(Year == target_year) %>%
  pivot_wider(
    id_cols  = Country,
    names_from  = Variable,
    values_from = Value,
    values_fn   = list(Value = ~ mean(.x, na.rm = TRUE))
  ) %>%
  mutate(
    Total_gen_TWh = `Electricity generation`,
    Hydro_TWh     = `Hydro generation`,
    Solar_GW      = `Solar capacity`,
    Wind_GW       = if ("Wind capacity" %in% names(.)) `Wind capacity` else NA_real_,
    BESS_MW       = `BESS capacity`,
    CCUS_Mt       = if ("CCUS capacity" %in% names(.)) `CCUS capacity` else NA_real_,
    Carbon_price  = if ("Carbon price" %in% names(.)) `Carbon price` else NA_real_
  ) %>%
  mutate(
    Hydro_share   = if_else(Total_gen_TWh > 0, Hydro_TWh / Total_gen_TWh, NA_real_),
    VREeq_TWh     = coalesce((Solar_GW * cf_solar * 8760) / 1000, 0) +
      coalesce((Wind_GW  * cf_wind  * 8760) / 1000, 0),
    VREeq_share   = if_else(Total_gen_TWh > 0, VREeq_TWh / Total_gen_TWh, NA_real_),
    BESS_per_TWh  = if_else(Total_gen_TWh > 0, BESS_MW / Total_gen_TWh, NA_real_),
    CCUS_per_TWh  = if_else(Total_gen_TWh > 0, CCUS_Mt  / Total_gen_TWh, NA_real_)
  )

# ---- Normalize indicators ----
indicator_defs <- c("Hydro_share","VREeq_share","BESS_per_TWh","CCUS_per_TWh","Carbon_price")

for (ind in indicator_defs) {
  if (!ind %in% names(features_2024)) {
    features_2024[[paste0(ind, "_n01")]] <- NA_real_
    next
  }
  v <- features_2024[[ind]]
  features_2024[[paste0(ind, "_n01")]] <- if (all(is.na(v))) NA_real_ else normalize_minmax_01(winsorize_vec(v, winsor_probs))
}

# ---- Sub-scores ----
features_2024 <- features_2024 %>%
  rowwise() %>%
  mutate(
    score_clean  = weighted_bucket_dynamic(c(hydro_share = Hydro_share_n01,
                                             vre_eq_share = VREeq_share_n01), w_clean),
    score_flex   = weighted_bucket_dynamic(c(bess_per_twh = BESS_per_TWh_n01), w_flex),
    score_policy = weighted_bucket_dynamic(c(ccus_per_twh = CCUS_per_TWh_n01,
                                             carbon_price = Carbon_price_n01), w_policy)
  ) %>%
  ungroup()

# ---- Final ERI scores ----
features_2024$ERI_0_1   <- apply(features_2024[, c("score_clean","score_flex","score_policy")], 1, function(rr) {
  names(rr) <- c("clean","flex","policy")
  m <- !is.na(rr)
  if (!any(m)) return(NA_real_)
  ww <- pillar_weights[m] / sum(pillar_weights[m])
  sum(rr[m] * ww)
})
features_2024$ERI_0_100 <- features_2024$ERI_0_1 * 100

# ---- Tidy output ----
eri_scores_2024 <- features_2024 %>%
  transmute(
    Country,
    Year = target_year,
    Hydro_share, VREeq_share, BESS_per_TWh, CCUS_per_TWh, Carbon_price,
    Hydro_share_n01, VREeq_share_n01, BESS_per_TWh_n01, CCUS_per_TWh_n01, Carbon_price_n01,
    score_clean, score_flex, score_policy,
    ERI_0_1, ERI_0_100
  ) %>%
  arrange(desc(ERI_0_1))

message("✅ ERI scores computed. Top preview:")
print(head(eri_scores_2024, 10))

# ================================================================
# (C) Save Outputs
# ================================================================
base_dir     <- dirname(file_path)
preindex_dir <- file.path(base_dir, "cleaned-Data", "pre-index")
final_dir    <- file.path(base_dir, "cleaned-Data", "FINAL")
dir.create(preindex_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(final_dir, recursive = TRUE, showWarnings = FALSE)

# Save inputs
write_csv(eri_long,  file.path(preindex_dir, "ERI_inputs_long_2020_2024.csv"))
# Save final scores
write_csv(eri_scores_2024, file.path(final_dir, "ERI_scores_2024_0to1_and_0to100.csv"))

cat("\n✅ Files written:\n")
cat("  • Pre-index inputs:", file.path(preindex_dir, "ERI_inputs_long_2020_2024.csv"), "\n")
cat("  • Final scores:     ", file.path(final_dir, "ERI_scores_2024_0to1_and_0to100.csv"), "\n")









































####4#########


# ================================================================
# GVC Development Report 2025 - Sustainability Readiness Pillar
# ELECTRONS INFRASTRUCTURE INDEX (EII) - FULL PIPELINE
# ================================================================
# Author: Anthony S Cano Moncada
# Description:
#   Cleans and transforms raw Ember/WRI "Energy.csv" dataset,
#   builds normalized indicators, computes EII scores (0–1, 0–100),
#   and exports replication-ready outputs.
# ================================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(readr)
  library(janitor)
})

# -----------------------------
# 0) Paths
# -----------------------------
data_root    <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX"
energy_file  <- file.path(data_root, "Energy.csv")
preindex_dir <- file.path(data_root, "cleaned-Data", "pre-index")
final_dir    <- file.path(data_root, "cleaned-Data", "FINAL")
dir.create(preindex_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(final_dir,    recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# 1) Load data
# -----------------------------
E0 <- read_csv(energy_file, show_col_types = FALSE) %>%
  clean_names() %>%
  rename(
    Country = area,
    ISO3    = iso_3_code
  ) %>%
  mutate(
    Year = as.integer(year),
    Variable = str_trim(variable),
    Unit     = str_trim(unit)
  )

# -----------------------------
# 2) Total generation (TWh)
# -----------------------------
gen_total <- E0 %>%
  filter(Variable == "Total Generation", Unit == "TWh") %>%
  select(Country, ISO3, Year, total_gen_twh = value)

# -----------------------------
# 3) Generation components (TWh)
# -----------------------------
components <- E0 %>%
  filter(
    Variable %in% c("Coal","Gas","Other Fossil",
                    "Hydro","Wind","Solar",
                    "Bioenergy","Other Renewables"),
    Unit == "TWh"
  ) %>%
  mutate(var_clean = make_clean_names(Variable)) %>%
  select(Country, ISO3, Year, var_clean, value) %>%
  pivot_wider(names_from = var_clean, values_from = value, values_fill = 0)

# -----------------------------
# 4) Emissions intensity / Net imports / Demand per capita
# -----------------------------
co2_intensity <- E0 %>%
  filter(Variable == "CO2 intensity") %>%
  select(Country, ISO3, Year, co2_intensity = value)

net_imports <- E0 %>%
  filter(Variable == "Net Imports", Unit == "TWh") %>%
  select(Country, ISO3, Year, net_imports_twh = value)

demand_pc <- E0 %>%
  filter(Variable == "Demand per capita", Unit == "MWh") %>%
  select(Country, ISO3, Year, demand_pc_mwh = value)

# -----------------------------
# 5) Assemble panel
# -----------------------------
panel <- gen_total %>%
  full_join(components,   by = c("Country","ISO3","Year")) %>%
  full_join(co2_intensity, by = c("Country","ISO3","Year")) %>%
  full_join(net_imports,   by = c("Country","ISO3","Year")) %>%
  full_join(demand_pc,     by = c("Country","ISO3","Year"))

# guarantee component cols exist
expected_comp <- c("coal","gas","other_fossil","hydro","wind","solar","bioenergy","other_renewables")
for (nm in expected_comp) if (!nm %in% names(panel)) panel[[nm]] <- 0

# compute derived totals/shares
panel <- panel %>%
  mutate(
    fossil_twh      = coalesce(coal,0) + coalesce(gas,0) + coalesce(other_fossil,0),
    clean_twh       = coalesce(hydro,0) + coalesce(wind,0) + coalesce(solar,0) +
                      coalesce(bioenergy,0) + coalesce(other_renewables,0),
    fossil_share_gen = if_else(total_gen_twh > 0, fossil_twh / total_gen_twh, NA_real_),
    clean_share_gen  = if_else(total_gen_twh > 0, clean_twh  / total_gen_twh, NA_real_),
    imports_share_gen = if_else(total_gen_twh > 0, net_imports_twh / total_gen_twh, NA_real_)
  )

# -----------------------------
# 6) Winsorize + normalize
# -----------------------------
winsorize_vec <- function(x, probs = c(0.05, 0.95)) {
  if (all(is.na(x))) return(x)
  qs <- quantile(x, probs = probs, na.rm = TRUE, names = FALSE)
  pmin(pmax(x, qs[1]), qs[2])
}
normalize_01 <- function(v) {
  if (all(is.na(v))) return(rep(NA_real_, length(v)))
  lo <- min(v, na.rm = TRUE); hi <- max(v, na.rm = TRUE)
  if (!is.finite(lo) || !is.finite(hi) || lo == hi) return(rep(0.5, length(v)))
  (v - lo) / (hi - lo)
}

# chosen indicators
raw_list <- list(
  clean_share_gen     = list(dir = "pos"),
  fossil_share_gen    = list(dir = "neg"),
  co2_intensity       = list(dir = "neg"),
  imports_share_gen   = list(dir = "neg"),
  demand_pc_mwh       = list(dir = "pos")   # optional
)

normed <- panel
for (nm in names(raw_list)) {
  if (!nm %in% names(normed)) normed[[nm]] <- NA_real_
  x <- normed[[nm]]
  x_w <- winsorize_vec(x)
  x_n <- normalize_01(x_w)
  if (raw_list[[nm]]$dir == "neg") x_n <- ifelse(is.na(x_n), NA_real_, 1 - x_n)
  normed[[paste0(nm, "_n01")]] <- x_n
}

# -----------------------------
# 7) Scoring (EII_year)
# -----------------------------
weights <- c(
  clean_share_gen_n01   = 0.30,
  fossil_share_gen_n01  = 0.25,
  co2_intensity_n01     = 0.25,
  imports_share_gen_n01 = 0.10,
  demand_pc_mwh_n01     = 0.10
)

weighted_bucket_dynamic <- function(values_named, weights_named) {
  present <- names(values_named)[!is.na(values_named)]
  if (length(present) == 0) return(NA_real_)
  ww <- weights_named[present]; ww <- ww / sum(ww)
  sum(values_named[present] * ww)
}

normed <- normed %>%
  rowwise() %>%
  mutate(
    EII_year = weighted_bucket_dynamic(
      c(
        clean_share_gen_n01   = clean_share_gen_n01,
        fossil_share_gen_n01  = fossil_share_gen_n01,
        co2_intensity_n01     = co2_intensity_n01,
        imports_share_gen_n01 = imports_share_gen_n01,
        demand_pc_mwh_n01     = demand_pc_mwh_n01
      ),
      weights
    )
  ) %>%
  ungroup()

# -----------------------------
# 8) Build final E object
# -----------------------------
E <- normed %>%
  select(Country, ISO3, Year, total_gen_twh,
         clean_share_gen_n01, fossil_share_gen_n01,
         co2_intensity_n01, imports_share_gen_n01, demand_pc_mwh_n01,
         EII_year)

# -----------------------------
# 9) RECENT_YEARS, country averages & latest year
# -----------------------------
finite_years <- E$Year[is.finite(E$Year)]
max_year <- max(finite_years, na.rm = TRUE)
RECENT_YEARS <- seq.int(max_year - 5L, max_year, by = 1L)

EII_country <- E %>%
  filter(Year %in% RECENT_YEARS) %>%
  group_by(Country, ISO3) %>%
  summarise(
    years_used = sum(!is.na(EII_year)),
    EII        = ifelse(years_used == 0, NA_real_, mean(EII_year, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  transmute(
    Country, ISO3, years_used,
    EII_0_1   = EII,
    EII_0_100 = round(100 * EII, 1)
  )

latest_year_by_cty <- E %>%
  filter(Year %in% RECENT_YEARS & !is.na(EII_year)) %>%
  group_by(Country, ISO3) %>%
  summarise(Year = max(Year), .groups = "drop")

EII_latest <- E %>%
  inner_join(latest_year_by_cty, by = c("Country","ISO3","Year")) %>%
  mutate(
    EII_0_1   = EII_year,
    EII_0_100 = round(100 * EII_year, 1)
  )

# -----------------------------
# 10) Exports
# -----------------------------
E_long_pre <- E %>%
  pivot_longer(-c(Country, ISO3, Year),
               names_to = "Field", values_to = "Value")

write_csv(E_long_pre,      file.path(preindex_dir, "EII_inputs_panel_long.csv"))
write_csv(EII_latest,      file.path(final_dir,    "EII_scores_latest_year_0to1_0to100.csv"))
write_csv(EII_country,     file.path(final_dir,    "EII_scores_country_0to1_0to100.csv"))

cat("\n✅ Electrons Infrastructure Index (EII) pipeline complete.\n",
    "Window (RECENT_YEARS): ", paste(RECENT_YEARS, collapse = ", "), "\n",
    "Pre-index panel:\n   • ", file.path(preindex_dir, "EII_inputs_panel_long.csv"), "\n",
    "Final outputs:\n   • ", file.path(final_dir, "EII_scores_latest_year_0to1_0to100.csv"), "\n",
    "   • ", file.path(final_dir, "EII_scores_country_0to1_0to100.csv"), "\n",
    sep = "")




#####5######

suppressPackageStartupMessages({
  library(readxl)
  library(dplyr)
})

file_path <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/IMFAI.xlsx"

# --- Load sheet, skipping first row ---
raw <- read_excel(file_path, sheet = "AIPI", skip = 1)

# --- Keep only original values: Country, ISO3, AIPI + add Year ---
aipi_final <- raw %>%
  select(Country, iso3, AIPI) %>%      # keep only needed columns
  rename(ISO3 = iso3) %>%              # rename for consistency
  mutate(Year = 2023) %>%              # add fixed year
  filter(!is.na(Country), !is.na(ISO3), !is.na(AIPI))

# --- Preview ---
head(aipi_final, 10)

# --- Save ---
out_file <- "/Volumes/VALEN/New Folder With Items 2/Update GVC INDEX/cleaned-Data/AIPI_2023.csv"
readr::write_csv(aipi_final, out_file)

message("Final AIPI (2023, raw values, restructured) saved to: ", out_file)

#####6####
